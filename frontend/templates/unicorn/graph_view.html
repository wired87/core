<div>
  {{ serializable_node_copy|json_script:"node-data" }}
  {{ edges|json_script:"edge-data" }}

  <div style="width: 100vw; height: 100vh; overflow: hidden;">
    {% if serializable_node_copy|length > 0 %}
      <canvas id="three-canvas"></canvas>
    {% else %}
      <form unicorn:submit.prevent="run_sim">
        <input type="text"
               unicorn:model.defer="task"
               unicorn:keyup.escape="task=''" placeholder="New task" id="task">
      </form>
      <button unicorn:click="run_sim">Run Sim</button>
    {% endif %}
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    <script src="https://app.unpkg.com/three-orbitcontrols@2.110.3/files/OrbitControls.js"></script>
    <script>


    let scene, camera, renderer, cubes = [];
    let lines = []; // Array zum Speichern der Linien
    let isSceneSetup = false; // Flag, um zu verfolgen, ob die Szene eingerichtet ist

    function setupScene() {
      const canvas = document.getElementById('three-canvas');
      if (!canvas) {
        console.warn("Canvas nicht gefunden.");
        return false;
      }

      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ canvas });
      renderer.setSize(window.innerWidth, window.innerHeight);
      const controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      isSceneSetup = true;
      console.log("Three.js Szene initialisiert.");
      return true;
    }

    function renderNodes(nodeData) {
      if (!isSceneSetup && !setupScene()) {
        console.warn("Konnte Szene nicht einrichten, Rendern abgebrochen.");
        return;
      }

      // Vorhandene Cubes entfernen
      cubes.forEach(c => scene.remove(c));
      cubes = [];

      nodeData.forEach(({ id, pos }) => {
        if (!pos || pos.length < 3) return;
        const cube = new THREE.Mesh(
          new THREE.BoxGeometry(1, 1, 1),
          new THREE.MeshBasicMaterial({ color: 0x00ffcc })
        );
        cube.position.set(pos[0], pos[1], pos[2]);
        scene.add(cube);
        cubes.push(cube);
      });

      console.log(`→ ${cubes.length} Cubes gerendert.`);
    }

    function renderEdges(edgeData, nodeData) {
        if (!isSceneSetup) {
            console.warn("Szene nicht initialisiert, Kanten können nicht gerendert werden.");
            return;
        }

        // Vorhandene Linien entfernen
        lines.forEach(l => scene.remove(l));
        lines = [];

        // Eine Map für schnellen Zugriff auf Knotenpositionen erstellen
        const nodePositions = new Map();
        nodeData.forEach(node => {
            if (node.id && node.pos && node.pos.length >= 3) {
                nodePositions.set(node.id, new THREE.Vector3(node.pos[0], node.pos[1], node.pos[2]));
            }
        });

        edgeData.forEach(({ src, trgt }) => {
            const startNodePos = nodePositions.get(src);
            const endNodePos = nodePositions.get(trgt);

            if (startNodePos && endNodePos) {
                const geometry = new THREE.BufferGeometry().setFromPoints([startNodePos, endNodePos]);
                const material = new THREE.LineBasicMaterial({ color: 0x888888 });
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                lines.push(line);
            } else {
                console.warn(`Knotenposition für Kante (${src} -> ${trgt}) nicht gefunden.`);
            }
        });
        console.log(`→ ${lines.length} Kanten gerendert.`);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (scene && camera && renderer) {
        controls.update();
        scene.rotation.y += 0.002;
        renderer.render(scene, camera);
      }
    }

    // Funktion zum Laden und Rendern beider Datensätze
    function loadAndRenderData() {
      const nodeDataElement = document.getElementById("node-data");
      const edgeDataElement = document.getElementById("edge-data");
      const canvas = document.getElementById("three-canvas");

      // Sicherstellen, dass Canvas und Daten-Elemente existieren
      if (!canvas || !nodeDataElement || !edgeDataElement) {
        console.log("Warte auf Canvas oder Daten-Elemente...");
        return;
      }

      // Szene einmalig initialisieren und Animation starten
      if (!isSceneSetup) {
        if (setupScene()) {
          animate();
        }
      }

      let nodeData = [];
      let edgeData = [];

      try {
        nodeData = JSON.parse(nodeDataElement.textContent);
        console.log("Node-Daten geladen:", nodeData);
      } catch (e) {
        console.error("Fehler beim Parsen der Node-Daten:", e);
      }

      try {
        edgeData = JSON.parse(edgeDataElement.textContent);
        console.log("Edge-Daten geladen:", edgeData);
      } catch (e) {
        console.error("Fehler beim Parsen der Edge-Daten:", e);
      }

      // Rendern der Knoten und Kanten
      renderNodes(nodeData);
      renderEdges(edgeData, nodeData); // Übergabe von nodeData für Kantenpositionen

      // Szene nach dem Rendern aktualisieren
      if (scene && camera && renderer) {
        renderer.render(scene, camera);
      }
    }

    // MutationObserver für Node-Daten
    const nodeDataObserver = new MutationObserver(() => {
      console.log("Node-Daten geändert, aktualisiere Szene...");
      loadAndRenderData();
    });

    // MutationObserver für Edge-Daten
    const edgeDataObserver = new MutationObserver(() => {
      console.log("Edge-Daten geändert, aktualisiere Szene...");
      loadAndRenderData();
    });

    // Registrieren der Observer, sobald das DOM geladen ist
    document.addEventListener("DOMContentLoaded", () => {
      // Nur Observer hinzufügen, wenn die Elemente existieren
      const nodeDataEl = document.getElementById("node-data");
      const edgeDataEl = document.getElementById("edge-data");

      if (nodeDataEl) {
        nodeDataObserver.observe(nodeDataEl, { childList: true, characterData: true, subtree: true });
      }
      if (edgeDataEl) {
        edgeDataObserver.observe(edgeDataEl, { childList: true, characterData: true, subtree: true });
      }

      // Initiales Laden und Rendern beim DOMContentLoaded
      loadAndRenderData();
    });

    // Auf unicorn:updated Event reagieren (alternative Methode zur Observer, falls Unicorn diese triggert)
    document.addEventListener("unicorn:updated", () => {
        console.log("Unicorn-Update erkannt, aktualisiere Szene...");
        loadAndRenderData();
    });
  </script>
</div>