{
    "params": {},
    "code": "import numpy as np\nfrom typing import Dict, Union\n\ndef _calculate_gamma(pi: np.ndarray, m: float) -> np.ndarray:\n    \"\"\"\n    Calculates the Lorentz factor gamma from the kinetic momentum pi.\n    This is derived from the standard relativistic relation gamma = sqrt(1 + |pi|^2 / m^2)\n    with c=1.\n    \n    Args:\n        pi (np.ndarray): Kinetic momentum vector(s) of shape (N, 3) or (3,).\n        m (float): Particle rest mass.\n\n    Returns:\n        np.ndarray: Lorentz factor gamma, a scalar or array of shape (N,).\n    \"\"\"\n    if pi.ndim == 1:\n        pi_sq = np.dot(pi, pi)\n    else:\n        pi_sq = np.einsum('...i,...i->...', pi, pi)\n    \n    gamma = np.sqrt(1.0 + pi_sq / (m**2))\n    return gamma\n\ndef calculate_v(pi: npndarray, gamma: np.ndarray, m: float) -> np.ndarray:\n    \"\"\"\n    Calculates the particle velocity vector v.\n    Ref: Equation (7).\n\n    Args:\n        pi (np.ndarray): Kinetic momentum vector(s) of shape (N, 3) or (3,).\n        gamma (np.ndarray): Lorentz factor gamma, scalar or array of shape (N,).\n        m (float): Particle rest mass.\n\n    Returns:\n        np.ndarray: Velocity vector(s) v of shape (N, 3) or (3,).\n    \"\"\"\n    # For arrays, gamma needs to be broadcastable to the shape of pi\n    if pi.ndim > 1 and gamma.ndim == 1:\n        gamma_exp = gamma[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n\n    v_vec = pi / (m * gamma_exp)\n    return v_vec\n\ndef calculate_F_vec(v: np.ndarray, E: np.ndarray, B: np.ndarray, e: float) -> np.ndarray:\n    \"\"\"\n    Calculates the Lorentz force field F.\n    Ref: Equation (8).\n\n    Args:\n        v (np.ndarray): Velocity vector(s) of shape (N, 3) or (3,).\n        E (np.ndarray): Electric field vector(s) at particle positions.\n        B (np.ndarray): Magnetic field vector(s) at particle positions.\n        e (float): Particle charge.\n\n    Returns:\n        np.ndarray: Lorentz force vector(s) F of shape (N, 3) or (3,).\n    \"\"\"\n    F_vec = e * (E + np.cross(v, B))\n    return F_vec\n\ndef calculate_a_F(v: np.ndarray, B: np.ndarray, e: float, m: float, gamma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the acceleration field of the nonradiative particle (synchrotron case).\n    Ref: Equation (13).\n\n    Args:\n        v (np.ndarray): Velocity vector(s) of shape (N, 3) or (3,).\n        B (np.ndarray): Magnetic field vector(s) at particle positions.\n        e (float): Particle charge.\n        m (float): Particle rest mass.\n        gamma (npndarray): Lorentz factor gamma, scalar or array of shape (N,).\n\n    Returns:\n        np.ndarray: Acceleration vector(s) a_F of shape (N, 3) or (3,).\n    \"\"\"\n    if v.ndim > 1 and gamma.ndim == 1:\n        gamma_exp = gamma[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        \n    a_F = (e / (m * gamma_exp)) * np.cross(v, B)\n    return a_F\n\ndef calculate_lambda_val(a_F: np.ndarray, gamma: np.ndarray, hbar: float, m: float) -> np.ndarray:\n    \"\"\"\n    Calculates the quantum scaling factor lambda.\n    Ref: Equation (11).\n\n    Args:\n        a_F (np.ndarray): Acceleration vector(s) of shape (N, 3) or (3,).\n        gamma (np.ndarray): Lorentz factor gamma, scalar or array of shape (N,).\n        hbar (float): Reduced Planck constant.\n        m (float): Particle rest mass.\n\n    Returns:\n        np.ndarray: Scalar lambda value(s) of shape (N,) or scalar.\n    \"\"\"\n    if a_F.ndim == 1:\n        a_F_norm_sq = np.dot(a_F, a_F)\n    else:\n        a_F_norm_sq = np.einsum('...i,...i->...', a_F, a_F)\n\n    a_F_norm_cubed = a_F_norm_sq**1.5\n    \n    lambda_val = (hbar / m**2) * (gamma**5) * a_F_norm_cubed\n    return lambda_val\n\ndef calculate_C_vec(a_F: np.ndarray, gamma: np.ndarray, e: float, m: float, pi: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the classical radiation-force field C.\n    Note: Using denominator 3*m^3 as per OCR of Eq (10).\n\n    Args:\n        a_F (np.ndarray): Acceleration vector(s) of shape (N, 3) or (3,).\n        gamma (np.ndarray): Lorentz factor gamma, scalar or array of shape (N,).\n        e (float): Particle charge.\n        m (float): Particle rest mass.\n        pi (np.ndarray): Kinetic momentum vector(s) of shape (N, 3) or (3,).\n\n    Returns:\n        np.ndarray: Classical radiation-force vector(s) C of shape (N, 3) or (3,).\n    \"\"\"\n    if a_F.ndim == 1:\n        a_F_norm_sq = np.dot(a_F, a_F)\n    else:\n        a_F_norm_sq = np.einsum('...i,...i->...', a_F, a_F)\n\n    # Expand dims for broadcasting if necessary\n    if pi.ndim > 1:\n        gamma_exp = gamma[:, np.newaxis]\n        a_F_norm_sq_exp = a_F_norm_sq[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        a_F_norm_sq_exp = a_F_norm_sq\n\n    C_vec = - (2.0 * e**2) / (3.0 * m**3) * (gamma_exp**3) * a_F_norm_sq_exp * pi\n    return C_vec\n\ndef calculate_Q_vec(lambda_val: np.ndarray, gamma: np.ndarray, pi: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the quantum radiation-force field Q.\n    Ref: Equation (16).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor, scalar or array of shape (N,).\n        gamma (npndarray): Lorentz factor gamma, scalar or array of shape (N,).\n        pi (np.ndarray): Kinetic momentum vector(s) of shape (N, 3) or (3,).\n\n    Returns:\n        np.ndarray: Quantum radiation-force vector(s) Q of shape (N, 3) or (3,).\n    \"\"\"\n    # Expand dims for broadcasting if necessary\n    if pi.ndim > 1:\n        gamma_exp = gamma[:, np.newaxis]\n        lambda_exp = lambda_val[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        lambda_exp = lambda_val\n\n    factor = (55.0 / (48.0 * np.sqrt(3.0))) * (1.0 / gamma_exp**2 + 1.0 / 6.0) * lambda_exp\n    Q_vec = factor * pi\n    return Q_vec\n\ndef calculate_B_orb(lambda_val: np.ndarray, pi: np.ndarray, gamma: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the orbital noise vector B_orb.\n    This is a 6-vector with the first 3 components (position) being zero.\n    Ref: Equation (23).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor, scalar or array of shape (N,).\n        pi (np.ndarray): Kinetic momentum vector(s) of shape (N, 3) or (3,).\n        gamma (np.ndarray): Lorentz factor gamma, scalar or array of shape (N,).\n\n    Returns:\n        np.ndarray: Orbital noise vector(s) B_orb of shape (N, 6) or (6,).\n    \"\"\"\n    if pi.ndim > 1:\n        N = pi.shape[0]\n        B_orb = np.zeros((N, 6))\n        gamma_exp = gamma[:, np.newaxis]\n        lambda_exp = lambda_val[:, np.newaxis]\n    else:\n        B_orb = np.zeros(6)\n        gamma_exp = gamma\n        lambda_exp = lambda_val\n\n    factor = np.sqrt(55.0 / (24.0 * np.sqrt(3.0)) * lambda_exp)\n    B_orb_pi_part = factor * (pi / gamma_exp)\n    B_orb[..., 3:6] = B_orb_pi_part\n    return B_orb\n\ndef calculate_Omega_TBMT(g: float, gamma: np.ndarray, B: np.ndarray, E: np.ndarray, v: np.ndarray, e: float, m: float) -> np.ndarray:\n    \"\"\"\n    Calculates the Thomas-BMT precession vector Omega_TBMT.\n    Note: Assuming (v.B)v term based on physical consistency.\n    Ref: Equation (36).\n\n    Args:\n        g (float): Particle's g-factor.\n        gamma (np.ndarray): Lorentz factor gamma.\n        B (np.ndarray): Magnetic field vector(s).\n        E (npndarray): Electric field vector(s).\n        v (np.ndarray): Velocity vector(s).\n        e (float): Particle charge.\n        m (float): Particle rest mass.\n\n    Returns:\n        np.ndarray: Thomas-BMT precession vector(s) of shape (N, 3) or (3,).\n    \"\"\"\n    a = (g - 2.0) / 2.0  # Anomalous magnetic moment\n\n    if v.ndim > 1:\n        gamma_exp = gamma[:, np.newaxis]\n        v_dot_B = np.einsum('...i,...i->...', v, B)[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        v_dot_B = np.dot(v, B)\n\n    term1_B = -(1.0 + a * gamma_exp) * B\n    term2_vBv = a * (gamma_exp**2 / (1.0 + gamma_exp)) * v_dot_B * v\n    term3_vxE = (a + 1.0 / (1.0 + gamma_exp)) * np.cross(v, E) # Note: paper has `1+a+...`\n    \n    # Paper's (36) has (e / (m * gamma)) as a prefactor. Let's use it.\n    Omega_TBMT = (e / (m * gamma_exp)) * (term1_B + term2_vBv + term3_vxE)\n    return Omega_TBMT\n\ndef calculate_B_spin(lambda_val: np.ndarray, a_F: np.ndarray, pi: np.ndarray, gamma: np.ndarray, m: float) -> np.ndarray:\n    \"\"\"\n    Calculates the spin noise vector B_spin.\n    Ref: Equation (39).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor.\n        a_F (npndarray): Acceleration vector(s).\n        pi (np.ndarray): Kinetic momentum vector(s).\n        gamma (np.ndarray): Lorentz factor gamma.\n        m (float): Particle rest mass.\n\n    Returns:\n        np.ndarray: Spin noise vector(s) B_spin of shape (N, 3) or (3,).\n    \"\"\"\n    if a_F.ndim == 1:\n        a_F_norm = np.linalg.norm(a_F)\n    else:\n        a_F_norm = np.linalg.norm(a_F, axis=1)\n\n    # Prevent division by zero\n    a_F_norm = np.where(a_F_norm == 0, 1e-30, a_F_norm)\n    \n    # Expand dims for broadcasting\n    if pi.ndim > 1:\n        gamma_exp = gamma[:, np.newaxis]\n        lambda_exp = lambda_val[:, np.newaxis]\n        a_F_norm_exp = a_F_norm[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        lambda_exp = lambda_val\n        a_F_norm_exp = a_F_norm\n    \n    factor = np.sqrt(24.0 * np.sqrt(3.0) / 55.0 * lambda_exp)\n    vec_part = np.cross(pi, a_F) / a_F_norm_exp\n    \n    B_spin = factor * (1.0 / (m * gamma_exp)) * vec_part\n    return B_spin\n\ndef calculate_D_spin_0_ST(lambda_val: np.ndarray, B_spin: np.ndarray) -> npndarray:\n    \"\"\"\n    Calculates the Sokolov-Ternov inhomogeneous drift term.\n    Ref: Equation (50).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor.\n        B_spin (np.ndarray): Spin noise vector.\n\n    Returns:\n        np.ndarray: Drift vector D_spin,0,ST of shape (N, 3) or (3,).\n    \"\"\"\n    if B_spin.ndim > 1 and lambda_val.ndim == 1:\n        lambda_exp = lambda_val[:, np.newaxis]\n    else:\n        lambda_exp = lambda_val\n        \n    factor = np.sqrt(55.0 / (24.0 * np.sqrt(3.0)) * lambda_exp)\n    D_spin_0_ST = factor * B_spin\n    return D_spin_0_ST\n\ndef calculate_D_spin_plus_TBMT_term(Omega_TBMT: np.ndarray, s: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the T-BMT part of the spin drift matrix applied to spin vector s.\n    Ref: Equation (51).\n\n    Args:\n        Omega_TBMT (np.ndarray): T-BMT precession vector.\n        s (npndarray): Spin vector(s).\n\n    Returns:\n        np.ndarray: Resulting drift term of shape (N, 3) or (3,).\n    \"\"\"\n    return np.cross(Omega_TBMT, s)\n\ndef calculate_D_spin_plus_ST_term(lambda_val: np.ndarray, s: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the Sokolov-Ternov part of the spin drift matrix applied to spin s.\n    Ref: Equation (52).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor.\n        s (np.ndarray): Spin vector(s).\n\n    Returns:\n        np.ndarray: Resulting drift term of shape (N, 3) or (3,).\n    \"\"\"\n    if s.ndim > 1 and lambda_val.ndim == 1:\n        lambda_exp = lambda_val[:, np.newaxis]\n    else:\n        lambda_exp = lambda_val\n        \n    D_spin_plus_ST_term = - (5.0 * np.sqrt(3.0) / 8.0) * lambda_exp * s\n    return D_spin_plus_ST_term\n\ndef calculate_D_spin_plus_BK_term(lambda_val: np.ndarray, pi: np.ndarray, gamma: np.ndarray, m: float, s: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Calculates the Baier-Katkov part of the spin drift matrix applied to spin s.\n    Ref: Equation (53).\n\n    Args:\n        lambda_val (np.ndarray): Quantum scaling factor.\n        pi (np.ndarray): Kinetic momentum vector(s).\n        gamma (npndarray): Lorentz factor gamma.\n        m (float): Particle rest mass.\n        s (np.ndarray): Spin vector(s).\n\n    Returns:\n        np.ndarray: Resulting drift term of shape (N, 3) or (3,).\n    \"\"\"\n    if s.ndim > 1:\n        gamma_exp = gamma[:, np.newaxis]\n        lambda_exp = lambda_val[:, np.newaxis]\n        pi_dot_s = np.einsum('...i,...i->...', pi, s)[:, np.newaxis]\n    else:\n        gamma_exp = gamma\n        lambda_exp = lambda_val\n        pi_dot_s = np.dot(pi, s)\n        \n    factor = (5.0 * np.sqrt(3.0) / (36.0 * m**2 * gamma_exp**2)) * lambda_exp\n    D_spin_plus_BK_term = factor * pi_dot_s * pi\n    return D_spin_plus_BK_term\n\ndef ito_step_full_spin_orbit(\n    y: np.ndarray,\n    dt: float,\n    E_field: np.ndarray,\n    B_field: np.ndarray,\n    constants: Dict[str, float]\n) -> np.ndarray:\n    \"\"\"\n    Performs a single Ito integration step for the full spin-orbit SDE system.\n    This orchestrates the calculation of all sub-components.\n    Ref: System (133) and its explicit form (137).\n\n    Args:\n        y (np.ndarray): Combined state vector [r, pi, s] of shape (N, 9) or (9,).\n        dt (float): Time step.\n        E_field (np.ndarray): Electric field at particle positions, shape (N, 3) or (3,).\n        B_field (np.ndarray): Magnetic field at particle positions, shape (N, 3) or (3,).\n        constants (Dict[str, float]): Dictionary of physical constants ('e', 'm', 'hbar', 'g').\n\n    Returns:\n        np.ndarray: The new state vector y_new of shape (N, 9) or (9,).\n    \"\"\"\n    e = constants['e']\n    m = constants['m']\n    hbar = constants['hbar']\n    g = constants['g']\n\n    # 1. Unpack state and calculate kinematics\n    q = y[..., 0:6]\n    r = q[..., 0:3]\n    pi = q[..., 3:6]\n    s = y[..., 6:9]\n    \n    gamma = _calculate_gamma(pi, m)\n    v = calculate_v(pi, gamma, m)\n\n    # 2. Calculate radiation and force terms\n    a_F = calculate_a_F(v, B_field, e, m, gamma)\n    lambda_val = calculate_lambda_val(a_F, gamma, hbar, m)\n    F_vec = calculate_F_vec(v, E_field, B_field, e)\n    C_vec = calculate_C_vec(a_F, gamma, e, m, pi)\n    Q_vec = calculate_Q_vec(lambda_val, gamma, pi)\n\n    # 3. Calculate Orbital Drift (D_orb)\n    D_orb_r = v\n    D_orb_pi = F_vec + C_vec + Q_vec\n    \n    if y.ndim > 1:\n        D_orb = np.hstack([D_orb_r, D_orb_pi])\n    else:\n        D_orb = np.concatenate([D_orb_r, D_orb_pi])\n\n    # 4. Calculate Spin Drift (D_spin)\n    Omega_TBMT = calculate_Omega_TBMT(g, gamma, B_field, E_field, v, e, m)\n    B_spin_val = calculate_B_spin(lambda_val, a_F, pi, gamma, m)\n    \n    D_spin_0_ST = calculate_D_spin_0_ST(lambda_val, B_spin_val)\n    D_spin_plus_TBMT_res = calculate_D_spin_plus_TBMT_term(Omega_TBMT, s)\n    D_spin_plus_ST_res = calculate_D_spin_plus_ST_term(lambda_val, s)\n    D_spin_plus_BK_res = calculate_D_spin_plus_BK_term(lambda_val, pi, gamma, m, s)\n\n    D_spin = D_spin_0_ST + D_spin_plus_TBMT_res + D_spin_plus_ST_res + D_spin_plus_BK_res\n\n    # 5. Calculate Diffusion Terms (B_orb, B_spin)\n    B_orb = calculate_B_orb(lambda_val, pi, gamma)\n    B_spin = B_spin_val # B_spin is directly the diffusion term for spin\n\n    # 6. Perform Ito Step\n    if y.ndim > 1:\n        num_particles = y.shape[0]\n        dw = np.random.normal(0.0, np.sqrt(dt), num_particles)\n        dw_q = dw[:, np.newaxis]\n        dw_s = dw[:, np.newaxis]\n    else:\n        dw = np.random.normal(0.0, np.sqrt(dt))\n        dw_q = dw\n        dw_s = dw\n\n    q_new = q + D_orb * dt + B_orb * dw_q\n    s_new = s + D_spin * dt + B_spin * dw_s\n\n    # 7. Pack and return new state\n    if y.ndim > 1:\n        y_new = np.hstack([q_new, s_new])\n    else:\n        y_new = np.concatenate([q_new, s_new])\n        \n    return y_new",
    "jax_code": "import jax\nimport jax.numpy as jnp\nfrom typing import NamedTuple\n\n# JAX-specific type hints for clarity\nArray = jax.Array\nPRNGKey = jax.random.PRNGKey\n\nclass State(NamedTuple):\n    \"\"\"Represents the state of a population of N particles.\"\"\"\n    r: Array   # Position, shape (N, 3)\n    pi: Array  # Kinetic Momentum, shape (N, 3)\n    s: Array   # Spin, shape (N, 3)\n\nclass Constants(NamedTuple):\n    \"\"\"Holds physical constants for the simulation.\"\"\"\n    e: float     # Charge\n    m: float     # Mass\n    hbar: float  # Reduced Planck constant\n    g: float     # g-factor\n\n# The following functions are designed to operate on single-particle inputs (e.g., shape (3,))\n# They are then vectorized over a population of N particles using jax.vmap.\n\ndef _calculate_gamma(pi: Array, m: float) -> Array:\n    \"\"\"Calculates the Lorentz factor gamma from kinetic momentum pi.\"\"\"\n    pi_sq = jnp.dot(pi, pi)\n    gamma = jnp.sqrt(1.0 + pi_sq / (m**2))\n    return gamma\n\ndef calculate_v(pi: Array, gamma: Array, m: float) -> Array:\n    \"\"\"Calculates the particle velocity vector v.\"\"\"\n    return pi / (m * gamma)\n\ndef calculate_F_vec(v: Array, E: Array, B: Array, e: float) -> Array:\n    \"\"\"Calculates the Lorentz force field F.\"\"\"\n    return e * (E + jnp.cross(v, B))\n\ndef calculate_a_F(v: Array, B: Array, e: float, m: float, gamma: Array) -> Array:\n    \"\"\"Calculates the acceleration field of the non-radiative particle.\"\"\"\n    return (e / (m * gamma)) * jnp.cross(v, B)\n\ndef calculate_lambda_val(a_F: Array, gamma: Array, hbar: float, m: float) -> Array:\n    \"\"\"Calculates the quantum scaling factor lambda.\"\"\"\n    a_F_norm_sq = jnp.dot(a_F, a_F)\n    a_F_norm_cubed = a_F_norm_sq**1.5\n    lambda_val = (hbar / m**2) * (gamma**5) * a_F_norm_cubed\n    return lambda_val\n\ndef calculate_C_vec(a_F: Array, gamma: Array, e: float, m: float, pi: Array) -> Array:\n    \"\"\"Calculates the classical radiation-force field C.\"\"\"\n    a_F_norm_sq = jnp.dot(a_F, a_F)\n    C_vec = - (2.0 * e**2) / (3.0 * m**3) * (gamma**3) * a_F_norm_sq * pi\n    return C_vec\n\ndef calculate_Q_vec(lambda_val: Array, gamma: Array, pi: Array) -> Array:\n    \"\"\"Calculates the quantum radiation-force field Q.\"\"\"\n    factor = (55.0 / (48.0 * jnp.sqrt(3.0))) * (1.0 / gamma**2 + 1.0 / 6.0) * lambda_val\n    Q_vec = factor * pi\n    return Q_vec\n\ndef calculate_B_orb(lambda_val: Array, pi: Array, gamma: Array) -> Array:\n    \"\"\"Calculates the orbital noise vector B_orb (a 6-vector).\"\"\"\n    factor = jnp.sqrt(55.0 / (24.0 * jnp.sqrt(3.0)) * lambda_val)\n    B_orb_pi_part = factor * (pi / gamma)\n    return jnp.concatenate([jnp.zeros(3), B_orb_pi_part])\n\ndef calculate_Omega_TBMT(g: float, gamma: Array, B: Array, E: Array, v: Array, e: float, m: float) -> Array:\n    \"\"\"Calculates the Thomas-BMT precession vector Omega_TBMT.\"\"\"\n    a = (g - 2.0) / 2.0\n    v_dot_B = jnp.dot(v, B)\n    \n    term1_B = -(1.0 + a * gamma) * B\n    term2_vBv = a * (gamma**2 / (1.0 + gamma)) * v_dot_B * v\n    term3_vxE = (a + 1.0 / (1.0 + gamma)) * jnp.cross(v, E)\n    \n    omega_tbmt = (e / (m * gamma)) * (term1_B + term2_vBv + term3_vxE)\n    return omega_tbmt\n\ndef calculate_B_spin(lambda_val: Array, a_F: Array, pi: Array, gamma: Array, m: float) -> Array:\n    \"\"\"Calculates the spin noise vector B_spin.\"\"\"\n    a_F_norm = jnp.linalg.norm(a_F)\n    a_F_norm_safe = jnp.where(a_F_norm == 0.0, 1e-30, a_F_norm)\n    \n    factor = jnp.sqrt(24.0 * jnp.sqrt(3.0) / 55.0 * lambda_val)\n    vec_part = jnp.cross(pi, a_F) / a_F_norm_safe\n    \n    B_spin = factor * (1.0 / (m * gamma)) * vec_part\n    return B_spin\n\ndef calculate_D_spin_0_ST(lambda_val: Array, B_spin: Array) -> Array:\n    \"\"\"Calculates the Sokolov-Ternov inhomogeneous drift term.\"\"\"\n    factor = jnp.sqrt(55.0 / (24.0 * jnp.sqrt(3.0)) * lambda_val)\n    D_spin_0_ST = factor * B_spin\n    return D_spin_0_ST\n\ndef calculate_D_spin_plus_TBMT_term(Omega_TBMT: Array, s: Array) -> Array:\n    \"\"\"Calculates the T-BMT part of the spin drift matrix applied to spin vector s.\"\"\"\n    return jnp.cross(Omega_TBMT, s)\n\ndef calculate_D_spin_plus_ST_term(lambda_val: Array, s: Array) -> Array:\n    \"\"\"Calculates the Sokolov-Ternov part of the spin drift matrix applied to spin s.\"\"\"\n    D_spin_plus_ST_term = - (5.0 * jnp.sqrt(3.0) / 8.0) * lambda_val * s\n    return D_spin_plus_ST_term\n\ndef calculate_D_spin_plus_BK_term(lambda_val: Array, pi: Array, gamma: Array, m: float, s: Array) -> Array:\n    \"\"\"Calculates the Baier-Katkov part of the spin drift matrix applied to spin s.\"\"\"\n    pi_dot_s = jnp.dot(pi, s)\n    factor = (5.0 * jnp.sqrt(3.0) / (36.0 * m**2 * gamma**2)) * lambda_val\n    D_spin_plus_BK_term = factor * pi_dot_s * pi\n    return D_spin_plus_BK_term\n\ndef _single_particle_step(\n    state: State,\n    dt: float,\n    E_field: Array,\n    B_field: Array,\n    constants: Constants,\n    key: PRNGKey\n) -> State:\n    \"\"\"Performs a JAX-compatible Ito integration step for a single particle.\"\"\"\n    # 1. Unpack state and constants\n    e, m, hbar, g = constants.e, constants.m, constants.hbar, constants.g\n    r, pi, s = state.r, state.pi, state.s\n\n    # 2. Calculate kinematics\n    gamma = _calculate_gamma(pi, m)\n    v = calculate_v(pi, gamma, m)\n\n    # 3. Calculate radiation and force terms\n    a_F = calculate_a_F(v, B_field, e, m, gamma)\n    lambda_val = calculate_lambda_val(a_F, gamma, hbar, m)\n    F_vec = calculate_F_vec(v, E_field, B_field, e)\n    C_vec = calculate_C_vec(a_F, gamma, e, m, pi)\n    Q_vec = calculate_Q_vec(lambda_val, gamma, pi)\n\n    # 4. Calculate Orbital Drift (D_orb)\n    D_orb_r = v\n    D_orb_pi = F_vec + C_vec + Q_vec\n    D_orb = jnp.concatenate([D_orb_r, D_orb_pi])\n\n    # 5. Calculate Spin Drift (D_spin)\n    Omega_TBMT = calculate_Omega_TBMT(g, gamma, B_field, E_field, v, e, m)\n    B_spin = calculate_B_spin(lambda_val, a_F, pi, gamma, m)\n    \n    D_spin_0_ST = calculate_D_spin_0_ST(lambda_val, B_spin)\n    D_spin_plus_TBMT_res = calculate_D_spin_plus_TBMT_term(Omega_TBMT, s)\n    D_spin_plus_ST_res = calculate_D_spin_plus_ST_term(lambda_val, s)\n    D_spin_plus_BK_res = calculate_D_spin_plus_BK_term(lambda_val, pi, gamma, m, s)\n    D_spin = D_spin_0_ST + D_spin_plus_TBMT_res + D_spin_plus_ST_res + D_spin_plus_BK_res\n\n    # 6. Calculate Diffusion Terms (B_orb, B_spin)\n    B_orb = calculate_B_orb(lambda_val, pi, gamma) # Shape (6,)\n\n    # 7. Perform Ito Step using a single Wiener process increment\n    dw = jax.random.normal(key) * jnp.sqrt(dt)\n    \n    q_old = jnp.concatenate([r, pi])\n    q_new = q_old + D_orb * dt + B_orb * dw\n    s_new = s + D_spin * dt + B_spin * dw\n\n    # 8. Pack and return new state\n    return State(r=q_new[0:3], pi=q_new[3:6], s=s_new)\n\n# Vectorize the single-particle step function across the population axis (0).\n# Arguments without an axis (None) are broadcast to all particles.\n_vmapped_step = jax.vmap(\n    _single_particle_step,\n    in_axes=(State(r=0, pi=0, s=0), None, 0, 0, None, 0)\n)\n\n@jax.jit\ndef ito_step_full_spin_orbit(\n    state: State,\n    dt: float,\n    E_field: Array,\n    B_field: Array,\n    constants: Constants,\n    key: PRNGKey\n) -> tuple[State, PRNGKey]:\n    \"\"\"\n    Performs a JIT-compiled, vectorized Ito integration step for a particle population.\n\n    This function orchestrates the update for an entire ensemble of particles\n    by applying the vmapped single-particle update function. It correctly handles\n    the PRNG key state for reproducible stochastic simulations.\n\n    Args:\n        state: A `State` PyTree with arrays of shape (N, 3).\n        dt: The scalar time step size.\n        E_field: Electric field at each particle, shape (N, 3).\n        B_field: Magnetic field at each particle, shape (N, 3).\n        constants: A `Constants` NamedTuple of physical parameters.\n        key: The master JAX random key for the step.\n\n    Returns:\n        A tuple containing:\n        - new_state (State): The updated state of the particle population.\n        - new_key (PRNGKey): The next PRNG key to be used in subsequent steps.\n    \"\"\"\n    key, step_key = jax.random.split(key)\n    num_particles = state.r.shape[0]\n    step_keys = jax.random.split(step_key, num_particles)\n    \n    new_state = _vmapped_step(state, dt, E_field, B_field, constants, step_keys)\n    \n    return new_state, key"
}