"""
RULES:
-modular
- return just code

jax
now create a prompt that gets this generated code string and converts it to jax code following best practice and highly optimized techniques on a fundamental level while keeping simplicity

"""

EXTRACT_EQUATIONS_PROMPT ="""
Task:Analyze the provided scientific document to identify and extract all equations essential for a state-of-the-art numerical simulation (e.g., Monte Carlo Particle Tracking). Your goal is to transform these mathematical constructs into a high-performance, programmatically relevant Python codebase that adheres to the highest physical standards and numerical accuracy.Strict Implementation Rules:Equation Identification & Extraction: * Systematically identify every equation required for the simulation (e.g., the Full spin-orbit SDE system and all its sub-components like $\vec{\Omega}_{TBMT}$, $\vec{\mathcal{C}}$, $\vec{\mathcal{Q}}$, and $\vec{B}_{spin}$).Create a separate Python function for each identified equation or logical sub-component.Programmatic Relevance & Variable Mapping:Capture the final result of every equation within a variable named exactly like the mathematical receiver/symbol used in the paper (e.g., omega_tbmt, C_vec, B_spin).You MUST research the definition of every mathematical symbol within the surrounding text (e.g., $a_{\mathcal{F}}$ for acceleration field, $\lambda$ for quantum scaling) and map these definitions exactly to the implementation.Strict Type Hinting:Include comprehensive Python type hints (numpy.ndarray, float, int) in every function header.The types must strictly reflect the dimensionality described in the paper (e.g., phase space $q \in \mathbb{R}^6$, spin $\vec{s} \in \mathbb{R}^3$).Modular Architecture:Drift Components: Implement dedicated functions for all deterministic components (Drift Vectors $\mathcal{D}$).Stochastic Components: Implement dedicated functions for all noise/stochastic components (Noise Vectors or Diffusion Matrices $\mathcal{B}$).Integration Logic: Create a primary update or step function that executes the formal stochastic integration (e.g., Ito calculus) by orchestrating the modular sub-functions.Physical Standards & Optimization:Use the exact unit system defined in the paper (e.g., SI-based with $c=1$).Pass physical constants ($e, m, \hbar$) as parameters or via a configuration object.Use numpy exclusively for vectorized calculations to ensure the code can handle large particle populations ($N$) with maximum performance.Serialization & Integrity:The resulting code must be fully serializable.Internal helper functions must start with an underscore (e.g., _calculate_gamma).Return ONLY the executable Python code string. Do not include markdown formatting, backticks, or explanatory text. The output must be ready for immediate programmatic execution.
Make nested function (def inside of def) names start with underscore (_) 
Design parameters, used by methods, GPU valid (avoid string values and dictionaries)
RETURN ONLY THE EXECUTABLE PYTHON STRING WHICH INCLUDES SINGLE PYTHON FUNCTIONS FOR EACH RELEVANT EQUATION
"""

CONV_EQ_CODE_TO_JAX_PROMPT = """
Task:Transform the provided Python/NumPy code string—which implements physical simulation equations (SDE systems)—into a fundamentally optimized and high-performance JAX implementation. The goal is to leverage JAX's transformation capabilities (JIT, Vmap) while maintaining the highest standards of numerical physics and code simplicity.Strict Implementation Rules:JAX Best Practices:Use jax.numpy for all mathematical operations to ensure compatibility with JIT compilation.Implement the update function as a pure function (no side effects) to allow for jax.jit decoration.Replace manual loops with jax.vmap to handle the particle population ($N$) in parallel across the phase space.Numerical Optimization:Ensure all operations are compatible with XLA (Accelerated Linear Algebra) compilation.Use jax.lax.scan or jax.lax.fori_loop if time-stepping is required within the JAX-transformed block to minimize host-device communication.Maintain numerical stability in physical limits (e.g., handling high-energy limits in $\gamma$ and $\vec{\Omega}_{TBMT}$).Structure & Variable Integrity:Keep the exact variable names for receivers (e.g., omega_tbmt, C_vec, B_spin) as defined in the source paper and the previous extraction.Maintain the modular architecture: separate functions for Drift ($\mathcal{D}$) and Noise/Diffusion ($\mathcal{B}$).State Management:Pass the PRNG key (jax.random.PRNGKey) as an explicit argument to functions involving stochasticity (Noise components).Handle state updates (position, momentum, spin) using a single structured state object (e.g., a NamedTuple or a simple Dict) to facilitate serialization and JAX transformations.Type Hinting: Maintain strict Python type hints for all JAX arrays (jax.Array) and scalars.Code Integrity:Return ONLY the executable Python/JAX code string.Do not include markdown formatting, backticks, or explanatory text.The code must be fundamentally optimized but remain as uncomplicated as possible for long-term maintainability.
Design parameters, used by methods, GPU valid (avoid string values and dictionaries)
Make nested function (def inside of def) names start with underscore (_) 
"""

